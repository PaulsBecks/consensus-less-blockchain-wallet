{"ast":null,"code":"\"use strict\";\n/**\n * nodeapi.js\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar params_1 = __importDefault(require(\"./params\"));\n/**\n * Node.js KeyWrapping function simply uses encrypt function.\n * @param keyToBeWrapped {Uint8Array} - plaintext key\n * @param wrappingKey {Uint8Array} - wrapping key\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\n\n\nexports.wrapKey = function (keyToBeWrapped, wrappingKey, _a, nodeCrypto) {\n  var name = _a.name,\n      iv = _a.iv;\n  return exports.encrypt(keyToBeWrapped, wrappingKey, {\n    name: name,\n    iv: iv\n  }, nodeCrypto, true);\n};\n/**\n * Node.js KeyUnwrapping function as well as keyWrapping\n * @param wrappedKey {Uint8Array} - Wrapped key\n * @param unwrappingKey {Uint8Array} - Key used for wrapping\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\n\n\nexports.unwrapKey = function (wrappedKey, unwrappingKey, _a, nodeCrypto) {\n  var name = _a.name,\n      iv = _a.iv;\n  return exports.decrypt(wrappedKey, unwrappingKey, {\n    name: name,\n    iv: iv\n  }, nodeCrypto, true);\n};\n/**\n * Encrypt plaintext message via AES Node.js crypto API\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @param wrapKey {Boolean} [false] - true if called as AES-KW\n * @return {Uint8Array} - Encrypted message byte array.\n * @throws {Error} - Throws error if UnsupportedCipher.\n */\n\n\nexports.encrypt = function (msg, key, _a, nodeCrypto, wrapKey) {\n  var name = _a.name,\n      iv = _a.iv,\n      additionalData = _a.additionalData,\n      tagLength = _a.tagLength;\n\n  if (wrapKey === void 0) {\n    wrapKey = false;\n  }\n\n  var alg = getNodeName(name, key.byteLength, wrapKey ? params_1.default.wrapKeys : params_1.default.ciphers);\n  var cipher;\n\n  switch (name) {\n    case 'AES-GCM':\n      {\n        cipher = nodeCrypto.createCipheriv(alg, key, iv, {\n          authTagLength: tagLength\n        });\n        cipher.setAAD(additionalData);\n        break;\n      }\n\n    case 'AES-CTR':\n      {\n        if (iv.length === 0 || iv.length > 16) throw new Error('InvalidIVLength');\n        var counter = new Uint8Array(16);\n        counter.set(iv);\n        counter[15] += 1;\n        cipher = nodeCrypto.createCipheriv(alg, key, counter);\n        break;\n      }\n\n    default:\n      {\n        // AES-CBC or AES-KW\n        cipher = nodeCrypto.createCipheriv(alg, key, iv);\n        break;\n      }\n  }\n\n  var body;\n  var final;\n  var tag;\n\n  try {\n    body = new Uint8Array(cipher.update(msg));\n    final = new Uint8Array(cipher.final());\n    tag = new Uint8Array([]);\n    if (name === 'AES-GCM') tag = new Uint8Array(cipher.getAuthTag());\n  } catch (e) {\n    throw new Error('NodeCrypto_EncryptionFailure');\n  }\n\n  var data = new Uint8Array(body.length + final.length + tag.length);\n  data.set(body);\n  data.set(final, body.length);\n  data.set(tag, body.length + final.length);\n  return data;\n};\n/**\n * Decrypt data through AES Node.js crypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @return {Uint8Array} - Decrypted message byte array.\n * @param unwrapKey {Boolean} [false] - true if called as AES-KW\n * @throws {Error} - Throws error if UnsupportedCipher or DecryptionFailure.\n */\n\n\nexports.decrypt = function (data, key, _a, nodeCrypto, unwrapKey) {\n  var name = _a.name,\n      iv = _a.iv,\n      additionalData = _a.additionalData,\n      tagLength = _a.tagLength;\n\n  if (unwrapKey === void 0) {\n    unwrapKey = false;\n  }\n\n  var alg = getNodeName(name, key.byteLength, unwrapKey ? params_1.default.wrapKeys : params_1.default.ciphers);\n  var decipher;\n  var body;\n\n  switch (name) {\n    case 'AES-GCM':\n      {\n        decipher = nodeCrypto.createDecipheriv(alg, key, iv, {\n          authTagLength: tagLength\n        });\n        decipher.setAAD(additionalData);\n        body = data.slice(0, data.length - tagLength);\n        var tag = data.slice(data.length - tagLength);\n        decipher.setAuthTag(tag);\n        break;\n      }\n\n    case 'AES-CTR':\n      {\n        if (iv.length === 0 || iv.length > 16) throw new Error('InvalidIVLength');\n        var counter = new Uint8Array(16);\n        counter.set(iv);\n        counter[15] += 1;\n        decipher = nodeCrypto.createDecipheriv(alg, key, counter);\n        body = data;\n        break;\n      }\n\n    default:\n      {\n        // AES-CBC or AES-KW\n        decipher = nodeCrypto.createDecipheriv(alg, key, iv);\n        body = data;\n        break;\n      }\n  }\n\n  var decryptedBody;\n  var final;\n\n  try {\n    decryptedBody = decipher.update(body);\n    final = decipher.final();\n  } catch (e) {\n    throw new Error('NodeCrypto_DecryptionFailure');\n  }\n\n  var msg = new Uint8Array(final.length + decryptedBody.length);\n  msg.set(decryptedBody);\n  msg.set(final, decryptedBody.length);\n  return msg;\n};\n/**\n * get node algorithm name\n * @param name {string} - name of webcrypto alg like AES-GCM\n * @param keyLength {number} - aes encryption key\n * @param dict {object} - params.ciphers or params.wrapKeys\n * @return {string} - node algorithm name\n */\n\n\nvar getNodeName = function (name, keyLength, dict) {\n  var alg = dict[name].nodePrefix;\n  alg = \"\" + alg + (keyLength * 8).toString();\n  return alg + dict[name].nodeSuffix;\n};","map":{"version":3,"sources":["/home/paul/Dokumente/Code/ConsensusLessBlockChain/consensusless-blockchain-wallet/node_modules/js-crypto-aes/dist/nodeapi.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","params_1","require","wrapKey","keyToBeWrapped","wrappingKey","_a","nodeCrypto","name","iv","encrypt","unwrapKey","wrappedKey","unwrappingKey","decrypt","msg","key","additionalData","tagLength","alg","getNodeName","byteLength","default","wrapKeys","ciphers","cipher","createCipheriv","authTagLength","setAAD","length","Error","counter","Uint8Array","set","body","final","tag","update","getAuthTag","e","data","decipher","createDecipheriv","slice","setAuthTag","decryptedBody","keyLength","dict","nodePrefix","toString","nodeSuffix"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * nodeapi.js\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar params_1 = __importDefault(require(\"./params\"));\n/**\n * Node.js KeyWrapping function simply uses encrypt function.\n * @param keyToBeWrapped {Uint8Array} - plaintext key\n * @param wrappingKey {Uint8Array} - wrapping key\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\nexports.wrapKey = function (keyToBeWrapped, wrappingKey, _a, nodeCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return exports.encrypt(keyToBeWrapped, wrappingKey, { name: name, iv: iv }, nodeCrypto, true);\n};\n/**\n * Node.js KeyUnwrapping function as well as keyWrapping\n * @param wrappedKey {Uint8Array} - Wrapped key\n * @param unwrappingKey {Uint8Array} - Key used for wrapping\n * @param name {string} - 'AES-KW'\n * @param iv {Uint8Array} - default is '0xA6A6A6A6A6A6A6A6'\n * @param nodeCrypto {Object} - NodeCrypto object\n * @return {Uint8Array} - Unwrapped Key\n */\nexports.unwrapKey = function (wrappedKey, unwrappingKey, _a, nodeCrypto) {\n    var name = _a.name, iv = _a.iv;\n    return exports.decrypt(wrappedKey, unwrappingKey, { name: name, iv: iv }, nodeCrypto, true);\n};\n/**\n * Encrypt plaintext message via AES Node.js crypto API\n * @param {Uint8Array} msg - Plaintext message to be encrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @param wrapKey {Boolean} [false] - true if called as AES-KW\n * @return {Uint8Array} - Encrypted message byte array.\n * @throws {Error} - Throws error if UnsupportedCipher.\n */\nexports.encrypt = function (msg, key, _a, nodeCrypto, wrapKey) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    if (wrapKey === void 0) { wrapKey = false; }\n    var alg = getNodeName(name, key.byteLength, (wrapKey) ? params_1.default.wrapKeys : params_1.default.ciphers);\n    var cipher;\n    switch (name) {\n        case 'AES-GCM': {\n            cipher = nodeCrypto.createCipheriv(alg, key, iv, { authTagLength: tagLength });\n            cipher.setAAD(additionalData);\n            break;\n        }\n        case 'AES-CTR': {\n            if (iv.length === 0 || iv.length > 16)\n                throw new Error('InvalidIVLength');\n            var counter = new Uint8Array(16);\n            counter.set(iv);\n            counter[15] += 1;\n            cipher = nodeCrypto.createCipheriv(alg, key, counter);\n            break;\n        }\n        default: { // AES-CBC or AES-KW\n            cipher = nodeCrypto.createCipheriv(alg, key, iv);\n            break;\n        }\n    }\n    var body;\n    var final;\n    var tag;\n    try {\n        body = new Uint8Array(cipher.update(msg));\n        final = new Uint8Array(cipher.final());\n        tag = new Uint8Array([]);\n        if (name === 'AES-GCM')\n            tag = new Uint8Array(cipher.getAuthTag());\n    }\n    catch (e) {\n        throw new Error('NodeCrypto_EncryptionFailure');\n    }\n    var data = new Uint8Array(body.length + final.length + tag.length);\n    data.set(body);\n    data.set(final, body.length);\n    data.set(tag, body.length + final.length);\n    return data;\n};\n/**\n * Decrypt data through AES Node.js crypto API.\n * @param {Uint8Array} data - Encrypted message to be decrypted.\n * @param {Uint8Array} key - Byte array of symmetric key.\n * @param {String} name - Name of AES algorithm like 'AES-GCM'.\n * @param {Uint8Array} [iv] - Byte array of initial vector if required.\n * @param {Uint8Array} [additionalData] - Byte array of additional data if required.\n * @param {Number} [tagLength] - Authentication tag length if required.\n * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.\n * @return {Uint8Array} - Decrypted message byte array.\n * @param unwrapKey {Boolean} [false] - true if called as AES-KW\n * @throws {Error} - Throws error if UnsupportedCipher or DecryptionFailure.\n */\nexports.decrypt = function (data, key, _a, nodeCrypto, unwrapKey) {\n    var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;\n    if (unwrapKey === void 0) { unwrapKey = false; }\n    var alg = getNodeName(name, key.byteLength, (unwrapKey) ? params_1.default.wrapKeys : params_1.default.ciphers);\n    var decipher;\n    var body;\n    switch (name) {\n        case 'AES-GCM': {\n            decipher = nodeCrypto.createDecipheriv(alg, key, iv, { authTagLength: tagLength });\n            decipher.setAAD(additionalData);\n            body = data.slice(0, data.length - tagLength);\n            var tag = data.slice(data.length - tagLength);\n            decipher.setAuthTag(tag);\n            break;\n        }\n        case 'AES-CTR': {\n            if (iv.length === 0 || iv.length > 16)\n                throw new Error('InvalidIVLength');\n            var counter = new Uint8Array(16);\n            counter.set(iv);\n            counter[15] += 1;\n            decipher = nodeCrypto.createDecipheriv(alg, key, counter);\n            body = data;\n            break;\n        }\n        default: { // AES-CBC or AES-KW\n            decipher = nodeCrypto.createDecipheriv(alg, key, iv);\n            body = data;\n            break;\n        }\n    }\n    var decryptedBody;\n    var final;\n    try {\n        decryptedBody = decipher.update(body);\n        final = decipher.final();\n    }\n    catch (e) {\n        throw new Error('NodeCrypto_DecryptionFailure');\n    }\n    var msg = new Uint8Array(final.length + decryptedBody.length);\n    msg.set(decryptedBody);\n    msg.set(final, decryptedBody.length);\n    return msg;\n};\n/**\n * get node algorithm name\n * @param name {string} - name of webcrypto alg like AES-GCM\n * @param keyLength {number} - aes encryption key\n * @param dict {object} - params.ciphers or params.wrapKeys\n * @return {string} - node algorithm name\n */\nvar getNodeName = function (name, keyLength, dict) {\n    var alg = dict[name].nodePrefix;\n    alg = \"\" + alg + (keyLength * 8).toString();\n    return alg + dict[name].nodeSuffix;\n};\n//# sourceMappingURL=nodeapi.js.map"]},"metadata":{},"sourceType":"script"}