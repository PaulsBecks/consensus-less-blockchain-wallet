{"ast":null,"code":"import sign from \"./sign\";\nimport { buf2hex, str2ab } from \"../strAb\";\nimport { ARR_SEPERATOR, SEPERATOR } from \"../../config\";\nimport findFormer from \"./findFormer\";\nimport getReferenceTransactions from \"./getReferenceTransactions\";\nimport getOpenTransaction from \"../blockchain/getOpenTransaction\";\n/***/\n\nfunction buildTransactionString({\n  sender,\n  receiver,\n  amount,\n  former,\n  refered\n}) {\n  return \"frm:\" + Object.keys(former).map(f => f + \"-\" + former[f]).reduce((former_string, f) => former_string == \"\" ? f : former_string + ARR_SEPERATOR + f, \"\") + SEPERATOR + \"snd:\" + sender + SEPERATOR + \"rcv:\" + receiver + SEPERATOR + \"amt:\" + amount + SEPERATOR + \"ref:\" + refered.reduce((refered_string, r) => refered_string == \"\" ? r : refered_string + ARR_SEPERATOR + r, \"\") + SEPERATOR;\n}\n\nfunction addSig(transactionString, sig) {\n  return transactionString + \"sig:\" + buf2hex(sig);\n}\n\nexport default async function (amount, receiver, wallet, endpoint) {\n  let former = findFormer(wallet, amount);\n\n  if (!former) {\n    console.log(\"Not enough balance apparently!\");\n    return null;\n  }\n\n  let refered = getReferenceTransactions(wallet, (await getOpenTransaction(endpoint)));\n  console.log(refered);\n  let transactionString = buildTransactionString({\n    amount,\n    receiver,\n    former,\n    sender: wallet.pem_pub_key,\n    refered\n  });\n  const sig = await sign(transactionString, wallet);\n  transactionString = addSig(transactionString, sig);\n  return transactionString;\n}","map":{"version":3,"sources":["/home/paul/Dokumente/Code/ConsensusLessBlockChain/consensusless-blockchain-wallet/src/services/wallet/createTransaction.js"],"names":["sign","buf2hex","str2ab","ARR_SEPERATOR","SEPERATOR","findFormer","getReferenceTransactions","getOpenTransaction","buildTransactionString","sender","receiver","amount","former","refered","Object","keys","map","f","reduce","former_string","refered_string","r","addSig","transactionString","sig","wallet","endpoint","console","log","pem_pub_key"],"mappings":"AAAA,OAAOA,IAAP,MAAiB,QAAjB;AACA,SAASC,OAAT,EAAkBC,MAAlB,QAAgC,UAAhC;AACA,SAASC,aAAT,EAAwBC,SAAxB,QAAyC,cAAzC;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,wBAAP,MAAqC,4BAArC;AACA,OAAOC,kBAAP,MAA+B,kCAA/B;AAEA;;AACA,SAASC,sBAAT,CAAgC;AAAEC,EAAAA,MAAF;AAAUC,EAAAA,QAAV;AAAoBC,EAAAA,MAApB;AAA4BC,EAAAA,MAA5B;AAAoCC,EAAAA;AAApC,CAAhC,EAA+E;AAC7E,SACE,SACAC,MAAM,CAACC,IAAP,CAAYH,MAAZ,EACGI,GADH,CACOC,CAAC,IAAIA,CAAC,GAAG,GAAJ,GAAUL,MAAM,CAACK,CAAD,CAD5B,EAEGC,MAFH,CAGI,CAACC,aAAD,EAAgBF,CAAhB,KACEE,aAAa,IAAI,EAAjB,GAAsBF,CAAtB,GAA0BE,aAAa,GAAGhB,aAAhB,GAAgCc,CAJhE,EAKI,EALJ,CADA,GAQAb,SARA,GASA,MATA,GAUAK,MAVA,GAWAL,SAXA,GAYA,MAZA,GAaAM,QAbA,GAcAN,SAdA,GAeA,MAfA,GAgBAO,MAhBA,GAiBAP,SAjBA,GAkBA,MAlBA,GAmBAS,OAAO,CAACK,MAAR,CACE,CAACE,cAAD,EAAiBC,CAAjB,KACED,cAAc,IAAI,EAAlB,GAAuBC,CAAvB,GAA2BD,cAAc,GAAGjB,aAAjB,GAAiCkB,CAFhE,EAGE,EAHF,CAnBA,GAwBAjB,SAzBF;AA2BD;;AAED,SAASkB,MAAT,CAAgBC,iBAAhB,EAAmCC,GAAnC,EAAwC;AACtC,SAAOD,iBAAiB,GAAG,MAApB,GAA6BtB,OAAO,CAACuB,GAAD,CAA3C;AACD;;AAED,eAAe,gBAAeb,MAAf,EAAuBD,QAAvB,EAAiCe,MAAjC,EAAyCC,QAAzC,EAAmD;AAChE,MAAId,MAAM,GAAGP,UAAU,CAACoB,MAAD,EAASd,MAAT,CAAvB;;AACA,MAAI,CAACC,MAAL,EAAa;AACXe,IAAAA,OAAO,CAACC,GAAR,CAAY,gCAAZ;AACA,WAAO,IAAP;AACD;;AACD,MAAIf,OAAO,GAAGP,wBAAwB,CACpCmB,MADoC,GAEpC,MAAMlB,kBAAkB,CAACmB,QAAD,CAFY,EAAtC;AAIAC,EAAAA,OAAO,CAACC,GAAR,CAAYf,OAAZ;AACA,MAAIU,iBAAiB,GAAGf,sBAAsB,CAAC;AAC7CG,IAAAA,MAD6C;AAE7CD,IAAAA,QAF6C;AAG7CE,IAAAA,MAH6C;AAI7CH,IAAAA,MAAM,EAAEgB,MAAM,CAACI,WAJ8B;AAK7ChB,IAAAA;AAL6C,GAAD,CAA9C;AAOA,QAAMW,GAAG,GAAG,MAAMxB,IAAI,CAACuB,iBAAD,EAAoBE,MAApB,CAAtB;AACAF,EAAAA,iBAAiB,GAAGD,MAAM,CAACC,iBAAD,EAAoBC,GAApB,CAA1B;AACA,SAAOD,iBAAP;AACD","sourcesContent":["import sign from \"./sign\";\nimport { buf2hex, str2ab } from \"../strAb\";\nimport { ARR_SEPERATOR, SEPERATOR } from \"../../config\";\nimport findFormer from \"./findFormer\";\nimport getReferenceTransactions from \"./getReferenceTransactions\";\nimport getOpenTransaction from \"../blockchain/getOpenTransaction\";\n\n/***/\nfunction buildTransactionString({ sender, receiver, amount, former, refered }) {\n  return (\n    \"frm:\" +\n    Object.keys(former)\n      .map(f => f + \"-\" + former[f])\n      .reduce(\n        (former_string, f) =>\n          former_string == \"\" ? f : former_string + ARR_SEPERATOR + f,\n        \"\"\n      ) +\n    SEPERATOR +\n    \"snd:\" +\n    sender +\n    SEPERATOR +\n    \"rcv:\" +\n    receiver +\n    SEPERATOR +\n    \"amt:\" +\n    amount +\n    SEPERATOR +\n    \"ref:\" +\n    refered.reduce(\n      (refered_string, r) =>\n        refered_string == \"\" ? r : refered_string + ARR_SEPERATOR + r,\n      \"\"\n    ) +\n    SEPERATOR\n  );\n}\n\nfunction addSig(transactionString, sig) {\n  return transactionString + \"sig:\" + buf2hex(sig);\n}\n\nexport default async function(amount, receiver, wallet, endpoint) {\n  let former = findFormer(wallet, amount);\n  if (!former) {\n    console.log(\"Not enough balance apparently!\");\n    return null;\n  }\n  let refered = getReferenceTransactions(\n    wallet,\n    await getOpenTransaction(endpoint)\n  );\n  console.log(refered);\n  let transactionString = buildTransactionString({\n    amount,\n    receiver,\n    former,\n    sender: wallet.pem_pub_key,\n    refered\n  });\n  const sig = await sign(transactionString, wallet);\n  transactionString = addSig(transactionString, sig);\n  return transactionString;\n}\n"]},"metadata":{},"sourceType":"module"}