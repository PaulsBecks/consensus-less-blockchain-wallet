{"ast":null,"code":"\"use strict\";\n/**\n * formatter.js\n */\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar encoder = __importStar(require(\"./encoder\"));\n\nvar PemArmorString = {\n  'public': 'PUBLIC KEY',\n  'private': 'PRIVATE KEY',\n  'encryptedPrivate': 'ENCRYPTED PRIVATE KEY',\n  'certificate': 'CERTIFICATE',\n  'certRequest': 'CERTIFICATE REQUEST'\n};\n/**\n * Convert PEM armored string to Uint8Array\n * @param keydataB64Pem\n * @return {Uint8Array}\n */\n\nexports.pemToBin = function (keydataB64Pem) {\n  var keydataB64 = dearmorPem(keydataB64Pem);\n  return encoder.decodeBase64(keydataB64);\n};\n/**\n * Convert ArrayBuffer or TypedArray to PEM armored string with a specified type\n * @param keydata\n * @param type\n * @return {string}\n */\n\n\nexports.binToPem = function (keydata, type) {\n  var keydataB64 = encoder.encodeBase64(keydata);\n  return formatAsPem(keydataB64, type);\n};\n/**\n * Armor the given Base64 string and return PEM formatted string\n * @param str\n * @param type\n * @return {string}\n */\n\n\nvar formatAsPem = function (str, type) {\n  var typeString = PemArmorString[type];\n  var finalString = \"-----BEGIN \" + typeString + \"-----\\n\";\n\n  while (str.length > 0) {\n    finalString += str.substring(0, 64) + \"\\n\";\n    str = str.substring(64);\n  }\n\n  finalString = finalString + \"-----END \" + typeString + \"-----\";\n  return finalString;\n};\n/**\n * Dearmor the given PEM string and return Base64 string\n * @param str\n * @return {string}\n */\n\n\nvar dearmorPem = function (str) {\n  // const beginRegExp = RegExp('^-----[\\s]*BEGIN[^-]*KEY-----$', 'gm');\n  // const endRegExp = RegExp('^-----[\\s]*END[^-]*KEY-----$', 'gm');\n  var beginRegExp = RegExp('^-----[\\s]*BEGIN[^-]*-----$', 'gm');\n  var endRegExp = RegExp('^-----[\\s]*END[^-]*-----$', 'gm'); // check if the object starts from 'begin'\n\n  try {\n    var dearmored = str.split(beginRegExp)[1].split(endRegExp)[0];\n    dearmored = dearmored.replace(/\\r?\\n/g, '');\n    return dearmored;\n  } catch (e) {\n    throw new Error('Invalid format as PEM');\n  }\n};","map":{"version":3,"sources":["/home/paul/Dokumente/Code/ConsensusLessBlockChain/consensusless-blockchain-wallet/node_modules/js-encoding-utils/dist/formatter.js"],"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","encoder","require","PemArmorString","pemToBin","keydataB64Pem","keydataB64","dearmorPem","decodeBase64","binToPem","keydata","type","encodeBase64","formatAsPem","str","typeString","finalString","length","substring","beginRegExp","RegExp","endRegExp","dearmored","split","replace","e","Error"],"mappings":"AAAA;AACA;;;;AAGA,IAAIA,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B,OAAOD,GAAP;AAC3B,MAAIE,MAAM,GAAG,EAAb;AACA,MAAIF,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIG,CAAT,IAAcH,GAAd,EAAmB,IAAII,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BN,GAA3B,EAAgCG,CAAhC,CAAJ,EAAwCD,MAAM,CAACC,CAAD,CAAN,GAAYH,GAAG,CAACG,CAAD,CAAf;AAC5ED,EAAAA,MAAM,CAAC,SAAD,CAAN,GAAoBF,GAApB;AACA,SAAOE,MAAP;AACH,CAND;;AAOAE,MAAM,CAACG,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,OAAO,GAAGX,YAAY,CAACY,OAAO,CAAC,WAAD,CAAR,CAA1B;;AACA,IAAIC,cAAc,GAAG;AACjB,YAAU,YADO;AAEjB,aAAW,aAFM;AAGjB,sBAAoB,uBAHH;AAIjB,iBAAe,aAJE;AAKjB,iBAAe;AALE,CAArB;AAOA;;;;;;AAKAJ,OAAO,CAACK,QAAR,GAAmB,UAAUC,aAAV,EAAyB;AACxC,MAAIC,UAAU,GAAGC,UAAU,CAACF,aAAD,CAA3B;AACA,SAAOJ,OAAO,CAACO,YAAR,CAAqBF,UAArB,CAAP;AACH,CAHD;AAIA;;;;;;;;AAMAP,OAAO,CAACU,QAAR,GAAmB,UAAUC,OAAV,EAAmBC,IAAnB,EAAyB;AACxC,MAAIL,UAAU,GAAGL,OAAO,CAACW,YAAR,CAAqBF,OAArB,CAAjB;AACA,SAAOG,WAAW,CAACP,UAAD,EAAaK,IAAb,CAAlB;AACH,CAHD;AAIA;;;;;;;;AAMA,IAAIE,WAAW,GAAG,UAAUC,GAAV,EAAeH,IAAf,EAAqB;AACnC,MAAII,UAAU,GAAGZ,cAAc,CAACQ,IAAD,CAA/B;AACA,MAAIK,WAAW,GAAG,gBAAgBD,UAAhB,GAA6B,SAA/C;;AACA,SAAOD,GAAG,CAACG,MAAJ,GAAa,CAApB,EAAuB;AACnBD,IAAAA,WAAW,IAAIF,GAAG,CAACI,SAAJ,CAAc,CAAd,EAAiB,EAAjB,IAAuB,IAAtC;AACAJ,IAAAA,GAAG,GAAGA,GAAG,CAACI,SAAJ,CAAc,EAAd,CAAN;AACH;;AACDF,EAAAA,WAAW,GAAGA,WAAW,GAAG,WAAd,GAA4BD,UAA5B,GAAyC,OAAvD;AACA,SAAOC,WAAP;AACH,CATD;AAUA;;;;;;;AAKA,IAAIT,UAAU,GAAG,UAAUO,GAAV,EAAe;AAC5B;AACA;AACA,MAAIK,WAAW,GAAGC,MAAM,CAAC,6BAAD,EAAgC,IAAhC,CAAxB;AACA,MAAIC,SAAS,GAAGD,MAAM,CAAC,2BAAD,EAA8B,IAA9B,CAAtB,CAJ4B,CAK5B;;AACA,MAAI;AACA,QAAIE,SAAS,GAAGR,GAAG,CAACS,KAAJ,CAAUJ,WAAV,EAAuB,CAAvB,EAA0BI,KAA1B,CAAgCF,SAAhC,EAA2C,CAA3C,CAAhB;AACAC,IAAAA,SAAS,GAAGA,SAAS,CAACE,OAAV,CAAkB,QAAlB,EAA4B,EAA5B,CAAZ;AACA,WAAOF,SAAP;AACH,GAJD,CAKA,OAAOG,CAAP,EAAU;AACN,UAAM,IAAIC,KAAJ,CAAU,uBAAV,CAAN;AACH;AACJ,CAdD","sourcesContent":["\"use strict\";\n/**\n * formatter.js\n */\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar encoder = __importStar(require(\"./encoder\"));\nvar PemArmorString = {\n    'public': 'PUBLIC KEY',\n    'private': 'PRIVATE KEY',\n    'encryptedPrivate': 'ENCRYPTED PRIVATE KEY',\n    'certificate': 'CERTIFICATE',\n    'certRequest': 'CERTIFICATE REQUEST'\n};\n/**\n * Convert PEM armored string to Uint8Array\n * @param keydataB64Pem\n * @return {Uint8Array}\n */\nexports.pemToBin = function (keydataB64Pem) {\n    var keydataB64 = dearmorPem(keydataB64Pem);\n    return encoder.decodeBase64(keydataB64);\n};\n/**\n * Convert ArrayBuffer or TypedArray to PEM armored string with a specified type\n * @param keydata\n * @param type\n * @return {string}\n */\nexports.binToPem = function (keydata, type) {\n    var keydataB64 = encoder.encodeBase64(keydata);\n    return formatAsPem(keydataB64, type);\n};\n/**\n * Armor the given Base64 string and return PEM formatted string\n * @param str\n * @param type\n * @return {string}\n */\nvar formatAsPem = function (str, type) {\n    var typeString = PemArmorString[type];\n    var finalString = \"-----BEGIN \" + typeString + \"-----\\n\";\n    while (str.length > 0) {\n        finalString += str.substring(0, 64) + \"\\n\";\n        str = str.substring(64);\n    }\n    finalString = finalString + \"-----END \" + typeString + \"-----\";\n    return finalString;\n};\n/**\n * Dearmor the given PEM string and return Base64 string\n * @param str\n * @return {string}\n */\nvar dearmorPem = function (str) {\n    // const beginRegExp = RegExp('^-----[\\s]*BEGIN[^-]*KEY-----$', 'gm');\n    // const endRegExp = RegExp('^-----[\\s]*END[^-]*KEY-----$', 'gm');\n    var beginRegExp = RegExp('^-----[\\s]*BEGIN[^-]*-----$', 'gm');\n    var endRegExp = RegExp('^-----[\\s]*END[^-]*-----$', 'gm');\n    // check if the object starts from 'begin'\n    try {\n        var dearmored = str.split(beginRegExp)[1].split(endRegExp)[0];\n        dearmored = dearmored.replace(/\\r?\\n/g, '');\n        return dearmored;\n    }\n    catch (e) {\n        throw new Error('Invalid format as PEM');\n    }\n};\n//# sourceMappingURL=formatter.js.map"]},"metadata":{},"sourceType":"script"}