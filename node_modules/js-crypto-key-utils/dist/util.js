"use strict";
/**
 * util.js
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var js_encoding_utils_1 = __importDefault(require("js-encoding-utils"));
var params = __importStar(require("./params"));
var asn1def_1 = require("./asn1def");
/**
 * Check if the given key is encrypted.
 * @param {DER|PEM} key - Private key object in ASN.1 encoding.
 * @param {AsnFormat} [format='pem'] - pem or der
 * @return {boolean} - True if encrypted.
 */
exports.isAsn1Encrypted = function (key, format) {
    if (format === void 0) { format = 'pem'; }
    var keyType;
    try {
        keyType = exports.getAsn1KeyType(key, format);
    }
    catch (e) {
        return false;
    }
    return keyType === 'encryptedPrivate';
};
/**
 * Check if the given key is public.
 * @param {DER|PEM} key - Public key object in ASN.1 encoding.
 * @param {AsnFormat} format - pem or der
 * @return {boolean} - True if public.
 */
exports.isAsn1Public = function (key, format) {
    if (format === void 0) { format = 'pem'; }
    var keyType;
    try {
        keyType = exports.getAsn1KeyType(key, format);
    }
    catch (e) {
        return false;
    }
    return (keyType === 'public');
};
/**
 * Retrieve the key type of public or private in ASN.1 format
 * @param {DER|PEM} key - Key object in ASN.1 encoding.
 * @param {AsnFormat} format - pem or der
 * @return {'public'|'private'|'encryptedPrivate'} - The key type of the given key.
 * @throws {Error} - Throws if NotSpkiNorPkcs8Key.
 */
exports.getAsn1KeyType = function (key, format) {
    if (format === void 0) { format = 'pem'; }
    // Peel the pem strings
    var binKey = (format === 'pem') ? js_encoding_utils_1.default.formatter.pemToBin(key) : key;
    var decoded = asn1def_1.KeyStructure.decode(Buffer.from(binKey), 'der');
    if (decoded.type === 'encryptedPrivateKeyInfo')
        return 'encryptedPrivate';
    else if (decoded.type === 'oneAsymmetricKey')
        return 'private';
    else if (decoded.type === 'subjectPublicKeyInfo')
        return 'public';
    else
        throw new Error('NotSpkiNorPkcs8Key');
};
/**
 * Retrieve the type of SEC1 octet key.
 * @param {OctetEC} sec1key - Key object in OctetEC encoding of Uint8Array.
 * @param {CurveTypes} namedCurve - Name of elliptic curve like 'P-256'.
 * @return {PublicOrPrivate} - public or private
 * @throws {Error} - Throws if UnsupportedKeyStructure.
 */
exports.getSec1KeyType = function (sec1key, namedCurve) {
    var len = params.namedCurves[namedCurve].payloadSize;
    var binKey = (sec1key instanceof Uint8Array) ? sec1key : js_encoding_utils_1.default.encoder.hexStringToArrayBuffer(sec1key);
    // original key type
    if (binKey.length <= len)
        return 'private';
    else if ((binKey.length === 2 * len + 1 && binKey[0] === 0x04)
        || (binKey.length === len + 1 && (binKey[0] === 0x02 || binKey[0] === 0x03)))
        return 'public';
    else
        throw new Error('UnsupportedKeyStructure');
};
/**
 * Check key type of JWK.
 * @param {JsonWebKey} jwkey - Key object in JWK format.
 * @return {PublicOrPrivate} - public or private
 * @throws {Error} - Throws if InvalidECKey, InvalidRSAKey or UnsupportedJWKType.
 */
exports.getJwkType = function (jwkey) {
    if (jwkey.kty === 'EC') {
        if (jwkey.x && jwkey.y && jwkey.d)
            return 'private';
        else if (jwkey.x && jwkey.y)
            return 'public';
        else
            throw new Error('InvalidECKey');
    }
    else if (jwkey.kty === 'RSA') {
        if (jwkey.n && jwkey.e && jwkey.d && jwkey.p && jwkey.q && jwkey.dp && jwkey.dq && jwkey.qi)
            return 'private';
        else if (jwkey.n && jwkey.e)
            return 'public';
        else
            throw new Error('InvalidRSAKey');
    }
    else
        throw new Error('UnsupportedJWKType');
};
/**
 * Prune leading zeros of an octet sequence in Uint8Array for jwk formatting of RSA.
 * https://tools.ietf.org/html/rfc7518#section-6.3
 * @param {Uint8Array} array - The octet sequence.
 * @return {Uint8Array} - An octet sequence pruned leading zeros of length equal to or shorter than the input array.
 * @throws {Error} - Throws if NonUint8Array.
 */
exports.pruneLeadingZeros = function (array) {
    var offset = 0;
    for (var i = 0; i < array.length; i++) {
        if (array[i] !== 0x00)
            break;
        offset++;
    }
    var returnArray = new Uint8Array(array.length - offset);
    returnArray.set(array.slice(offset, array.length));
    return returnArray;
};
// for pem/oct/der formatting from jwk of RSA
/**
 * Append leading zeros and generate an octet sequence of fixed length.
 * @param {Uint8Array} array - An octet sequence.
 * @param {Number} len - Intended length of output sequence.
 * @returns {Uint8Array} - An octet sequence with leading zeros.
 * @throws {Error} - Throws if NonUint8Array or InvalidLength.
 */
exports.appendLeadingZeros = function (array, len) {
    if (array.length > len)
        throw new Error('InvalidLength');
    var returnArray = new Uint8Array(len); // initialized with zeros
    returnArray.set(array, len - array.length);
    return returnArray;
};
//# sourceMappingURL=util.js.map